var should = require('../node_modules/should/should'),
    fixture = require('./inc/fixture'),
    locEntity = require('./inc/LocEntity'),
    MediatorMock = require('./inc/MediatorMock'),
    SourceCodeStub = require('./inc/SourceCodeStub'),
    sniffClass = require('../lib/Sniff/SyntaxTree/CompoundStatementConventions');


describe('CompoundStatementConventions', function () {
  describe('(Contract)', function () {
    var pNode = null,
        mediator,
        sniff,
        msg;

      beforeEach(function(){
        mediator = new MediatorMock();
        msg = false;
     });
     it('must throw exception when invalid rule.for given', function () {
        sniff = new sniffClass( new SourceCodeStub( "code" ), mediator );
        (function(){
          sniff.run( { "for": true, "requireBraces": true, "requireMultipleLines": true }, null );
        }).should.throw();
      });
    });
    /**
     * testing IfStatement
     */
    describe('with IfStatement', function () {
      var pNode = null,
          mediator,
          msg,
          sniff,
          statement = "IfStatement",
          caseId = "case1";

      beforeEach(function(){
        mediator = new MediatorMock();
        msg = false;
     });

      it('must trigger violation on (if(1) a = 1;) when braces required', function () {
         var rule = {
           "for": [ statement ],
           "requireBraces": true,
           "requireMultipleLines": false
         };
         sniff = new sniffClass( new SourceCodeStub( fixture.getText( "CompoundStatementConventions/" + caseId + ".fail.js" )
           ), mediator );

         pNode = fixture.getJson( "CompoundStatementConventions/" + caseId + ".fail.json" ).body[ 0 ];
         sniff.run( rule, pNode );
         msg = mediator.getMessage( "CompoundStatementRequireBraces" );
         msg.should.be.ok;
         //mediator.getMessages().should.not.be.ok;
       });
    });

});
